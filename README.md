# Java-basic
<!-- 본 문서는 _2022-04-28_ 에 작성되었습니다. -->

# JDK 설치
> Java 8 버전 이용<br>
> https://www.oracle.com/java/technologies/downloads/

운영체제 선택해서 설치 파일 다운로드 > resource 폴더에 옮기기 <br> 
설치파일 실행해서 설치 진행(경로는 Program Files 안에 Java 폴더인지 확인) <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; > 윈도우 검색에다 환경 검색 > 시스템 환경 변수 편집 클릭 > 환경 변수 버튼 클릭 <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; > 아래쪽에 새로만들기 클릭해서 변수 만들기 <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 변수명 : JAVA_HOME <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 변수 값 : jdk 설치된 경로(C:\Program Files\Java\jdk1.8.0_311) <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; > Path변수 찾아서 편집 > 새로운 창에서 새로 만들기 클릭 > <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; %JAVA_HOME%\bin 작성 후 확인 > 모든 창 닫고 cmd 실행 > javac -version 명령어 수행 <br>

# 통합 개발 환경(IDE)
> Eclipse 19-12버전 이용<br>
> https://www.eclipse.org/downloads/packages/release/2019-12/r

Perspective 는 Java로 바꿔준다


# 단축키
|단축키|동작|
|--|--|
|Ctrl + F11|실행|
|Ctrl + Spacebar|자동완성|
|Ctrl + /|주석 처리<br>(주석이 되어있는 줄이라면 해제)|
|Alt + Shift + N > ↓ > Enter|프로젝트 만들기
|Ctrl + N|New창<br>(클래스, 패키지, .. 등등 만드는 창)|
|Ctrl + Alt + ↓(↑)|아래(위)쪽으로 한줄 복사|
|Alt + ↓(↑)|아래(위)쪽으로 한줄 이동|
|Ctrl + Shift + F|자동 정렬|
|Ctrl + M|현재 창 최대크기로|
|Ctrl + 클릭|선언된 곳으로 이동|
|Alt + Shift + A|여러줄 동시에 선택해서 수정하기|
|Alt + Shift + S > O|필드를 이용해서 생성자 만들기(부모 생성자 선택 가능)|
|Alt + Shift + R|선언부와 사용부를 동시에 이름 변경|
|Alt + Shift + S > C|부모 클래스의 생성자 그대로 받아와서 생성자 만들기|
|Alt + Shift + S > R|getter setter 메서드 만들기|
|Alt + Shift + Z > ↓ > enter|try~catch문|


# 1. 출력 메서드
`System.out`

- .print(값) <br>
괄호 안에 있는 값을 그대로 출력<br>
마지막에 줄바꿈을 하지 않는다.<br>

- .println(값)<br>
print()와 동일, 마지막에 줄바꿈을 한다.

- .printf()<br>
System.out.printf("서식문자열",값1,값2,...);<br><br>
서식문자열 : 서식문자가 포함된 문자열 <br>
ex) "%fcm" --> 실수한개 뒤에 "cm"라는게 붙은 문자열<br><br>
뒤에 올 값들은 앞에 문자열에 있는 서식문자대로 따라와야 한다.<br>
printf("키 : %fcm",170.24); ---> 키 : 170.24cm<br>

## 서식문자(format문자)
> 따옴표 안에 존재한다.<br>
> %와 함께 쓰인다.

|서식문자|동작|
|--|--|
| %d | 정수|
| %c | 문자 |
| %s | 문자열 |
| %f | 실수 |
| %% | % |

## 제어문자
> 따옴표 안에 존재한다.<br>
> \와 함께 쓰인다.

|제어문자|동작|
|--|--|
|`\n`|Enter(줄바꿈)|
|`\t`|Tab(공백)|
|`\"`|"|
|`\'`|'|
|`\\`|`\`|
	
# 2. 변수<br>
`단 하나의 값을 저장할 수 있는 메모리 공간`<br>
프로그래밍언어에서의 변수란, 값을 저장할 수 있는 메모리상의 공간을 의미한다.<br>

하나의 변수에 단 하나의 값만 저장할 수 있으므로, <br>
새로운 값을 저장하면 기존의 값은 사라진다.

## 자료형
|자료형|type|byte|예|
|--|--|--|--|
|정수형|int|4|0, -110, 244, ...(-21억 ~ 21억)
|   |long|8|0L, -110L, 244l, ...
|실수형|float|4|0.0F, -1207.1f, 12.417f, ...
|   |double|8|0.0, -1207.1, 12.417, ...
|문자형|char|2|'0', '가', 'A', '~', ...
|문자열|String|??|"0", "HELLO", "", ...

## 변수의 선언과 주의사항 <br>
자료형 변수명 = 초기값; <br>
자료형 변수명; <br>
- 같은 이름의 변수를 선언할 수 없다.
- 초기화를 해준다.
- 되도록 선언부(메서드 상단)에 한꺼번에 선언한다.

## 형변환 <br>
자바에서는 정수와 정수의 연산은 결과도 정수로 나온다.<br>
실수로 된 결과를 받으려면 피연산자(항)를 실수로 바꿔주는 방법이 필요하다.

### 자동 형변환 <br>
정수 + 실수 ---> 실수 <br>
문자 + 정수 ---> 정수 <br>
문자열 + 정수, 실수, ... ---> 문자열 <br>

### 강제 형변환 <br>
(자료형)값
(double)10

# 3. 입력 메서드
`new Scanner(System.in)` <br>
매번 반복해서 써주기엔 너무 길기 때문에 아래처럼 사용한다.
```java
Scanner scan = new Scanner(System.in);
scan.next();
scan.nextLine();
scan.nextInt();
```
- .next() <br>
사용부분 통째로 사용자가 입력한 문자열 값<br>
공백 또는 엔터를 구분점으로 판단하고 분리하여 입력받는다.<br>
해 진이 : "해", "진이"로 분리하여 "해"만 입력받는다.<br>
띄어쓰기가 포함된 경우에는 값의 개수만큼 next()를 사용해 주어야 한다.<br>

- nextLine() <br>
사용부분 통째로 사용자가 입력한 문자열 값 <br>
공백도 문자로 입력받는다. <br>
앞에 다른 입력이 있다면 의미없는 nextLine()을 한번 미리 써주어야 한다. <br>

- nextInt() <br>
사용부분 통째로 사용자가 입력한 정수 값

# 우선순위 <br>
`한 문장 안에 다양한 연산자가 있을 때 먼저 연산하는 순위` <br>
- 최우선 연산자<br>
() .

- 단항 연산자 <br>
! ~ 형변환연산자 <br>
!A : A조건식의 연산결과가 true라면 false로, false라면 true로 바꿔준다. <br>

- 산술 연산자
- 쉬프트 연산자 <br>
`>>` &nbsp; a >> b : a를 b만큼 우측으로 비트이동 <br>
`<<` &nbsp; a << b : a를 b만큼 좌측으로 비트이동

- 관계 연산자 <br>
조건식을 만드는데 사용되는 연산자 <br>
비교 연산자 <br>
\>, < : 초과, 미만 <br>
\>=, <= : 이상, 이하 <br>
\== : 같다 <br>
!= : 다르다 <br>

- 논리 연산자 <br>
여러 조건식들의 관계를 설정해주는 연산자 <br>
A, B는 조건식으로 가정한다. <br>
A && B  &nbsp; : 두 조건식의 연산 결과가 둘 다 true면 true <br>
A || B  &nbsp; : 두 조건식의 연산 결과중 하나라도 true면 true <br>

- 삼항 연산자 <br>
조건식 ? 참이면 오는부분 : 거직이면 오는부분 <br>
조건식 ? 참일때의 값 : 거짓일때의 값 <br>
삼항연산자는 사용부분 통째로 값 <br>
`경우의 수가 단 두가지의 값으로 나올 경우에 사용`

- 대입 연산자

# 4. 제어문 <br>
위에서 아래로만 흐르던 코드의 흐름을 제어하기 위한 문장 <br>

## 4.-1 조건문 <br>
- 조건에 따라 경우의 수를 나누기
- 흐름을 여러가지로 나누기
- 선택지를 주어줄 때
- 특정한 상태 물어볼 때 (입력한게 5이니? 입력한 비밀번호가 qwer이니?)

### if문 <br>
> if ~ else if ~ else <br>
> 조건식 중 하나가 참이라면 내부 내용을 수행하고 세트를 탈출한다.(아래 내용은 하지 않는다.)<br>
> 모든 조건식들이 거짓이라면 else문까지 내려가서 그 내부를 수행한다.<br>
> else if와 else문은 생략이 가능하다.

```java
if(조건식1){
	조건식1의 연산결과가 true일 때 수행할 문장
	...
} else if(조건식2){
	조건식 2의 연산결과가 true일 때 수행할 문장
	...
}
..
else{
	위의 조건식들이 모두 false일 때 수행할 문장
	...
}
```
### switch문 <br>
> switch ~ case ~ default <br>
> 경우의 수가 변수에 담긴 값 등가 비교로 인해 나뉠 때 사용 <br>
> 변수에 담긴 값에 따라 알맞은 case로 이동하고 문장을 실행한다.(진입점 선택)<br>
> 하지만 그 밑에 case가 더 있다면 그 안에있는 문장들도 실행된다.<br>
> 따라서 각 케이스들을 나누어 주려면 알맞게 break; 를 사용해야 한다.<br>

```java
switch(변수){
case 값1:
	변수에 담긴 값이 값1 일때 수행
	break;
case 값2:
	변수에 담긴 값이 값2 일때 수행
	break;
...
default:
	위의 값들이 아닐 때 수행
}
```
### 기타 제어 (break, continue) <br>
`break` : 속해있는 switch문이나 반복문을 탈출한다. <br>
`continue` : 다음 반복으로 넘어가기 / 반복시 해야할 행위들은 함<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (while : 조건식 검사 / for : 증감식, 조건식 검사)

### 누적 대입 연산자(복합 대입 연산자, 누적 연산자)<br>
`+=` `-=` `/=` `*=` <br>
```java
int data = 10;
data = data+5;

data += 5;	//(data 공간에 5만큼 더해서 넣어라!)
```

#### 증감 연산자
data += 1 &nbsp;&nbsp;&nbsp; -> data++; <br>
data -= 1 &nbsp;&nbsp;&nbsp; -> data--; <br>

### 전위형 <br>
해당 줄부터 적용
```java
int data = 10;
System.out.println(++data);	//11
```

### 후위형 <br>
다음 줄 부터 적용
```java
int data = 10;
System.out.println(data++);	//10
System.out.println(data);	//11
```

## 4.-2 반복문 <br>
- 특정한 코드나 행위를 반복해야 할 때 사용하는 문장


### while문 <br>
> 조건식 검사 -> 참이라면 내부수행, 거짓이면 탈출 <br>
> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -> 조건식 재검사 -> 참이라면 내부수행, 거짓이면 탈출 <br>
> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -> 조건식 재검사 ...

```java
while(조건식) {
	조건식이 참일동안 반복할 문장
}
```

### 무한반복 <br>
> while문 뒤에 () 안에는 조건식, 즉 boolean 타입의 값이 와야한다.<br>
> 따라서 그 안에 true라는 값을 넣을 수 있고, 그 값은 상수로 작성했기<br>
> 때문에 변하지 않는다. 따라서 그 while문은 무한정으로 반복하게 된다.<br>
> 안에서 특정한 조건을 if문으로 만들어 주고 그 때 break를 통한<br>
> 탈출구 하나 이상을 만들어 주어야 한다.<br>

```java
while(true){
	무한반복할 문장
}
```

### do ~ while문 <br>
> while문과 동일하지만 처음 한번은 무조건 실행한다.<br>
> 내부수행 -> 조건식검사 -> 참이라면 내부수행, 거짓이면 탈출 <br>
> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -> 조건식 재검사 -> 참이라면 내부수행, 거짓이면 탈출 <br>
> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -> 조건식 재검사 ...

```java
do {
	조건식이 참일동안 반복할 문장
} while(조건식);
```

### for문 <br>
> 횟수에 의한 반복문 <br>
> 반복 횟수가 특정된 경우에 사용한다. <br>
> 무언가 값이 일정하게 변하는 반복이라면 99.99% for문을 사용한다. <br>

```java
for (초기식; 조건식; 증감식){
	수행할 문장
}
```
- 초기식 : 변수 하나를 선언해준다.(내부에서 이 변수를 사용 가능)
- 조건식 : 매 반복 전에 조건식 검사(참이면 반복, 거짓이면 탈출)
- 증감식 : 초기식에 선언한 변수의 증감을 설정 <br>

### 2중 for문 (nested for문) <br>
> for문 안에 for문이 있는 형태 <br>
> 바깥쪽에 있는 i for문은 다음 반복으로 넘어가기 위해서 <br>
> 자신 내부에 있는 수행할 문장들을 모두 마쳐야 한다. <br>
> 안쪽에 수행할 문장으로 j for문이 있으므로, 그 j for문이 <br>
> 완벽히 모두 완료되어야 i for문 입장에서 내부에 수행할 문장을 <br>
> 마친것이 된다. 따라서 j for문이 완전히 끝나면 그제서야 <br>
> i for문은 다음 반복으로 넘어가게 되고 다시 수행할 문장으로 <br>
> j for문을 만나면 위의 과정을 반복하게 된다. 가장 안쪽에 있는 <br>
> 문장은 (i for문 반복횟수) * (j for문 반복횟수) 만큼 수행된다. <br>


# 5. 배열
> 같은 자료형의 여러 변수를 나열해 놓은 것 <br>

```java
자료형[] 배열명 = {값1, 값2, ...};
자료형[] 배열명 = new 자료형[칸수];
```

#### 배열의 사용 이유
- 여러 같은 의미의 값들을 하나의 인덱스로 관리하기 위해
- 다른 의미의 값들에 의미부여를 해서 하나로 관리하기 위해

#### 배열의 길이
> 배열명.length <br>

## 5.-1 2차원 배열
> 배열 안에 배열 <br>

```java
자료형[][] 배열명 {
	{값1, 값2, ...},
	{값3, 값4, ...},
	...
}
자료형[][] 배열명 = new 자료형[행수][열수];
```

- 정방배열: 각 행마다 열의 개수가 모두 같은 배열
- 비정방배열 : 각 행마다 열의 개수가 다른 배열

## String 클래스
> 문자열의 본질은 문자배열 <br>
> 값을 담은 문자배열 + 유용한 메서드 --> 문자열 클래스로 구현 <br>

```java
"Hello" --> char[] --> {'H', 'e', 'l', 'l', 'o'}
```

|메서드|사용법|설명(반환 자료형)|
|--|--|--|
|split()|"문자열1".split("문자열2");|"문자열1"을 "문자열2" 기준으로 나누기 (String[] 반환)|
|cahrAt(n)|"문자열".charAt(n);|"문자열"의 n번째 글자(char 반환)|
|indexOf()|"문자열".indexOf("문자열2");|"문자열1"에서 "문자열2"가 시작하는 인덱스(int 반환)|
|equals()|"문자열1".equals("문자열2");|"문자열1"과 "문자열2"가 같은지 비교(boolean 반환)|
|length()|"문자열".length();|"문자열"의 길이(int 반환)|
|replace()|"문자열1".replace("문자열2","문자열3");|"문자열1" 에서 "문자열2" 를 찾아 "문자열3"으로 반환(String 반환)|
|subString(n)|"문자열".subString(n);|"문자열"을 n부터 끝까지 잘라서 돌려주기(String 반환)|
|subString(n, m)|"문자열".subString(n, m);|"문자열"을 n부터 m 이전까지 잘라서 돌려주기(String 반환)|
|trim()|"문자열".trim();|"문자열" 양 옆에 있는 공백을 제거(String 반환)|

# 6. 메서드 Method
이름 뒤에 소괄호 <br>
단, 키워드 뒤에 ()나 클래스 뒤에 ()는 메서드가 아니다. <br>
> 반복되는 코드, 기능, 행위, 처리 등을 쉽게 관리하기 위해 사용한다. <br>
> 반복이 규칙적이지 않고 우리가 원할때 특정 코드를 수행하게 하고 싶을 때 <br>
> 메서드로 만들어놓고 후에 호출해서 사용한다. <br>

```java
①리턴타입 ②메소드명(③자료형 매개변수, 자료형 매개변수, ...){
	④호출시 실행할 문장
	⑤return 리턴값;
}
```
①`리턴타입` : return 뒤의 값의 타입에 맞는 자료형을 작성해준다. <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 리턴값이 없을 때에는 void로 작성한다.<br>
② `메서드명` : 동사형으로 작성한다. eat("치킨") eat("피자") eat("햄버거") <br>
③ `자료형 매개변수` : 생략이 가능하다. 하지만 생략시에는 외부(사용하는 곳)에서 값을 <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 전달받을 수 없다. 여러 값을 전달받아야 할 경우에는 ,로 구분하여 <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 그 값들 만큼 선언해 주어야 한다. 사용시에는 매개변수의 타입과 <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 개수에 맞게 순서대로 값을 전달해 주어야 한다. <br>
④ `호출시 실행할 문장` : 생략이 가능하다. 메소드 호출때마다 수행해야하는 코드를 그대로 작성한다. <br>
⑤ `return` : 생략이 가능하다. <br>

## 6.-1 메서드 사용
> 메서드는 클래스 내부에 있으므로 그 메서드가 속해있는 클래스 타입으로 <br>
> 먼저 변수를 만들어 주어야 한다. (`객체화`를 진행해주어야 한다.)

```java
클래스명 변수명 = new 클래스명();

변수.메서드명();		//매개변수가 없는것은 그대로 이름으로 사용한다.
변수.메서드명(값1,값2,...);	//매개변수의 개수와 타입에 맞게 값을 넘겨준다.
```

> 메서드 사용 부분은 선언부 마지막에 return값이 있다면 사용한 부분 통째로 <br>
> 그 리턴값으로 보아야 한다. 단, return값이 없다면 절대 값으로 봐서는 안된다. <br>

## 6.-2 Storage Class (저장 기억 부류)
- 지역 변수 : 메서드 내부에 선언된 변수
- 전역 변수 : 클래스 내부에, 메서드 바깥에 선언된 변수<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;각 객체마다 하나씩 필드로 존재하는 변수
- 정적 변수 : static이 붙은 변수

|	|지역변수|전역변수|정적변수|
|--|--|--|--|
|초기화|직접|자동|자동|
|생명주기|}|프로그램 종료시|프로그램 종료시|
|접근성|하|중|상|

# 7.Class (클래스) 반<br>
> 여러 변수들과 메서드들을 둘 다 관리하기 위해 설계하고 사용한다. <br>
> 공통 요소들을 추상적으로 묶어놓은 틀 <br>
> 붕어빵 틀 <br>

- 주어이다. <br>
	System.out,println(); <br>
	모든 문장 맨 앞에는 클래스가 나오고<br>
	영어는 맨 앞을 항상 대문자로 적는다.<br>
	따라서 클래스는 주어이고, 대문자로 시작한다.<br>
	```java
	String food = "banana";
	Monkey.eat(food);
	[주어] [동사][목적어]
	```
- 타입이다. <br>
	클래스는 추상적인 개념이고 이 클래스 안에는 필드가 존재한다. <br>
	추상적인것을 바로 사용할 수 없기 때문에 그 필드들을 <br>
	구체화시킨 대상이 필요하다. 이러한 것들을 `"객체"` 라고 부르고 <br>
	영어로는 instance variable 이라고 부른다.(붕어빵) <br>

	instance 예, 예시라는 뜻이고 추상적인 개념의 한 예시로서 <br>
	객체가 나오기 때문에 instance variable 이라 부른다. <br>
	(자동차인데 예를들어 내차 말이야) <br>
	[클래스] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [객체] <br>

	추상적인 개념인 클래스를 객체로 구체화 해서 만드는 작업을 <br>
	객체화라고 한다. <br>
	클래스명 객체명; <br>
	
	따라서 클래스는 이 때 만들어지는 객체의 타입이다. <br>

## 7.-1 클래스 선언과 사용
### 클래스 선언
```java
Class 클래스명{
	필드(변수, 메서드)
}
```
### 클래스 사용
> 클래스는 추상적인 틀이기 때문에 먼저 객체화를 진행한다. <br>
```java
클래스명 객체명 = new 클래스명();
객체.메서드명()
객체.변수명
```

하나의 저장공간에는 단 한개의 값만 담을 수 있다. <br>
필드에는 여러개의 값이 존재하기 때문에 필드는 다른곳(Heap)에 <br>
할당되고 할당된 필드의 주소값을 저장하는 것이 객체이다. <br>

## 7.-2 생성자
> 클래스명 뒤에 소괄호 <br>
> 생성자는 메서드와 똑같은 기능을 가지고 있다. <br>
> 하지만 객체를 생성해 주고 리턴을 할 수 없기 때문에 메서드라고 부르지 않는다. <br>
> <br>
> 클래스 선언시 자동으로 생성자가 하나 만들어지고 코드상에는 나타나지 않는다. <br>
> 이러한 생성자를 기본 생성자라고 하며, 만약 직접 생성자를 선언하게 되면 <br>
> 기존에 있던 기본 생성자는 사라지게 된다. <br>

### 생성자의 목적
1. 클래스의 필드를 똑같이 복사해서 메모리에 할당해주고 할당된 <br>필드의 주소값을 돌려받기 위함 / 객체화의 목적
2. 호출시 내부의 내용을 수행하기 위함 / 초기화의 목적

#### null
> 주소의 초기값

### this <br>
> 클래스 선언시 내부적으로 선언되어 생성된다. <br>
> 클래스 필드에서 하나의 메서드 선언으로 여러 객체를 다루어야 한다. <br>
> 만약 메서드 내에서 필드를 사용하고자 할 때 어떤 객체의 필드인지를 <br>
> 알 수 없다. 따라서 객체에 마침표를 찍고 필드에 접근하거나 어떤 <br>
> 객체를 생성중에는 현재 접근한 그 객체를 this 변수가 받는다. <br>
> 결과적으로 클래스 선언시 this.필드명 으로 접근하면 여러 객체를<br>
> 하나의 메서드에서 구분하여 다룰 수 있게된다. (객체 구별용 변수) <br>

## 7.-3 Polymorphism(다형성) <br>
### Overloading (오버로딩) <br>
> 같은 이름의 메서드를 넘쳐서(여러개) 불러오는(선언하는) 기법 <br>
> 매개변수의 개수 혹은 타입이 다르다면 매개변수로 각각을 구별할 <br>
> 수 있기 때문에 같은 이름의 메서드로 여러개 선언할 수 있다. <br>
> 오버로딩된 메서드를 사용할 시 전달된 값의 타입 혹은 개수로 <br>
> 구분하여 알맞은 메서드가 자동으로 호출된다. <br>

### Overriding (오버라이딩) : 재정의 <br>
> 부모 필드에 a() 라는 메서드가 존재한다면 자식 객체 생성시 <br>
> 부모 필드가 먼저 메모리에 올라가게 되므로 부모의 a()가 <br>
> 메모리에 먼저 존재한다. 그 다음 자식 필드를 완성시킬때 <br>
> 똑같은 이름의 a() 라는 메서드가 존재한다면 같은 이름으로 <br>
> 2개가 만들어지는것이 아니라 기존에 만들어진 부모필드의 <br>
> a() 메서드 대신에 자식에서 작성한 내용이 사용된다. <br>
> (부모 필드에 있는 a()에 자식에서 작성한 내용이 덮어씌워진다) <br>
> 그러므로 자식 객체로 a() 메서드를 사용하게 되면 재정의된 <br>
> 기능으로 사용하며 이것을 오버라이딩 이라고 한다.


## 7.-4 클래스 배열 <br>
> 객체를 여러개 선언해야 하는 경우 배열 타입으로 한번에 선언 후 사용<br>
> 각 객체는 규칙성이 없기 때문에 규칙성을 부여하기 위해서 사용 <br>
> 한칸 한칸이 하나의 객체 <br>

```java
클래스명[] 배열명 = {
	new 생성자(),
	new 생성자(),
	new 생성자(),
	...
};

클래스명[] 배열명 = new 클래스명[칸수];
```

### 클래스 배열 사용
> 각 칸이 객체이기 때문에 각 방으로 접근 후 .을 찍고 필드로 접근한다.
```java
배열명[idx].변수
배열명[idx].메서드()
```

## 7.-5 상속(inheritance)
> 1. 기존에 선언된 클래스의 필드를 다른 클래스에서도 사용하고자 할 때 <br>
> 2. 클래스들을 만들다 보니 공통 요소가 보여서 부모로 묶은 후 상속시켜 <br>
> 주어서 클래스를 편하게 만들고자 할 때

### 상속 방법
```java
class A{
	A의 필드
}
class B extends A{
	B의 필드
}
B obj = new B();
//obj 객체는 실제로 A의 필드와 B의 필드 둘 다 가지고 있다.
```
- A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스 <br>
- B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스 <br>

### 자식 클래스의 생성자 호출시 일어나는 일
> 자식 클래스의 객체는 자식 생성자를 호출하여 객체화를 진행한다. <br>
> 자식 생성자를 호출했으므로 자식 클래스 내의 필드들이 똑같이 <br>
> 복사되어 하나 생성된다. 만약 자식 클래스의 필드만 메모리에 <br>
> 올라갔다면 자식 객체로 절대 부모 클래스 내부에 있는 필드에는 <br>
> 접근할 수가 없다. 따라서 자식 생성자를 호출하게 되면 _부모의 <br>
> 필드가 먼저 메모리에 할당_ 되고 그 이후에 자식 필드도 따라 붙는다. <br>
> 결과적으로 자식 객체는 부모 필드가 메모리에 같이 올라와 있기 때문에 <br>
> 접근할 수 있게된다. <br>
>> 자식 생성자 첫 줄에는 항상 super클래스의 생성자가 호출된다. <br>
	명시적으로 적지 않을시에는 보이지 않지만 super(); 호출 <br>

## static (정적)
> static이 붙은 변수, 메서드, 구역 등은 프로그램 실행시 가장 먼저<br>
> 메모리에 올라간다. static이 붙은 메서드 내부에서는 객체의 필드에<br>
> 올라오는 일반 전역변수나 일반 메서드는 사용할 수 없다. <br>
> (아직 메모리에 올라오지 않았기 때문에)<br>
> 따라서 static이 붙은 전역변수, static이 붙은 메서드, <br>
> 자기 자신 안에 선언된 지역변수만 사용할 수 있다. <br><br>
> static이 붙은 전역변수, 메서드는 모든 객체가 공유한다. <br>
> 따라서 static 필드는 클래스 이름으로 직접 점근이 가능하다. <br>
> 실제로 공유해야 하는 값, 메서드 또는 필드가 필요없는 메서드 경우에는 <br>
> static을 붙여서 선언한다. <br>
> (공유하지 않아야 하는 값들에는 무조건 static을 붙이면 안된다.) <br>

# 8. 캐스팅 (Casting)

## 8.-1 업 캐스팅(Up casting) <br>
> 자식 타입의 객체를 부모 타입으로 변환 <br>
> 부모 타입의 객체에 자식 클래스의 필드를 담아주는 것 <br>
```java
SuperCar supercar = new SuperCar();
Car car = supercar;
```

> 부모 타입의 객체에 자식 생성자를 호출<br>
```java
Car car = new SuperCar();
```

> 부모 타입의 매개변수에 자식 객체를 넘기는 것
```java
void f(Car car) {

}
f(new SuperCar());
```

> 업캐스팅 된 객체는 자식 클래스에서 추가한 내용을 사용할 수 없다. <br>
> 단, 오버라이딩 된 메서드는 사용 가능하다. <br>

## 8.-2 다운 캐스팅(Down casting) <br>
> 업 캐스팅 된 객체를 다시 자식타입으로 바꾸는 것 <br>
> 업 캐스팅 시 잘려나갔던 자식클래스의 추가된 내용을 다시 달아주는 것 <br>
>> (자식클래스)업캐스팅된객체

## 8.-3 instanceof
> 객체 instanceof 클래스명 <br>
> 객체가 뒤에오는 클래스 타입인지 비교 <br>
> true / false 두 가지 결과로 나오는 조건식

# 9. 접근 권한 제어자
> 다른 패키지 혹은 다른 클래스에서 해당 필드에 접근할 수 있는<br>
> 권한을 제어해주는, 설정해주는 키워드들 <br>

- (default) : 다른 패키지에서 접근 불가
- public : 모든 곳에서 접근 가능
- private : 다른 클래스, 다른 패키지에서 접근 불가
- protected : 다른 패키지에서 접근 불가 / <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 단 자식은 자신의 필드처럼 접근 가능

|접근 권한 제어자|사용용도|
|--|:--:|
|public|모든곳에서 자유롭게 접근이 가능해야 하는 필드들<br>(데이터를 처리하고 기능을 담당하는 메서드들)|
|private|데이터를 담는 변수들<br>(게시글 제목, 회원, 아이디, ...)|
|protected|상속이 목적<br>(자식 클래스들이 오버라이딩 해서 써야하는 메서드)|
|(default)|확실하게 같은 패키지에서만 이용할 때, 귀찮을 떄|

> private 필드는 직접 접근할 방법이 하나도 없기 때문에 무조건 <br>
> public 메서드를 통해서 간접적으로 접근한다. <br>
> (값을 사용하는 경우 : getter / 수정하는 경우 : setter)

# 10. 추상 클래스(불완전한 클래스)
> 추상적인 내용만 정의하고 있는 클래스로, 구체적인 내용은 존재하지 않는 클래스<br>
> 상속받은 하위 클래스에서 그 내용들을 구현하도록 설계된 클래스이다. <br>
> 추상 클래스(부모)는 클래스들(자식)의 공통 요소들을 추상적으로 <br>
> 가상화 시켜놓기 때문에 객체화시 자식에서 재정의를 통한 구현을 하고 <br>
> 그 자식타입으로 객체화를 진행해서 사용한다. 부모 추상 클래스의 역할은 <br>
> 단지 자식 클래스를 만들 때 틀로 존재해서 도와주는 역할을 수행한다. <br>
> 그렇기 때문에 자식 클래스에서 재정의 해야되는 메서드의 이름과 형태만 <br>
> 가지고 있다. 즉 메서드에 {}(바디)가 없다. 이러한 메서드를 추상 메소드 <br>
> 라고 하며, abstract 라는 키워드가 리턴타입 앞에 붙는다. 추상 메서드가 <br>
> 하나라도 포함되어 있다면 그 클래스는 추상 클래스로 만들어야 한다. <br>

## 10.-1 추상 클래스 선언
```java
abstract class 추상클래스명 {
	abstract 리턴타입 추상메서드명();
}
```
> 추상 메서드는 자식 클래스에서 강제적으로 반드시 재정의 해야한다. <br>
> 일반 메서드는 추상 클래스 내부에 존재할 수 있다. <br>

## 10.-2 인터페이스
> 추상 클래스를 고도화시킨 문법이며, 반드시 추상메서드와 상수만 선언해야 한다. <br>
> 다른 클래스에서 인터페이스를 지정받을 때에는 immplements 라는 키워드를 사용한다. <br>
> 지정받은 클래스는 인터페이스가 가지고 있는 추상 메서드를 반드시 재정의 해야한다. <br>

> jdk 8버전 이후로부터는 인터페이스에 default 메서드를 선언할 수 있다. <br>
> 따라서 사실상의 다중상속을 지원하게 된다. <br>
> 인터페이스 끼리나 다른 클래스와의 메서드 모호성이 발생한다면<br>
> (같은 이름의 메서드끼리 충돌이 발생한다면) 상속받은 클래스에서<br>
> 명시적으로 작성(오버라이딩)해 주어 모호성을 해결해 주어야 한다.<br>
> 내부에서는<br>
> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 인터페이스명.super.메서드()<br>
> 로 지정받은 인터페이스에 있는 메서드를 호출할 수 있고 이는 다중상속을<br>
> 받을 수 있다는 것을 의미한다.<br>

# 11. 내부 클래스(inner class)
> 클래스 내부에 클래스를 선언하며 외부 클래스의 필드에 용이하게 접근하기 <br>
> 위해서 사용한다. 내부 클래스의 필드를 사용하기 위해서는 먼저 외부 클래스의 <br>
> 객체를 만들고 그 객체를 통해 내부 클래스까지 접근해서 객체화를 해야한다. <br>


> 외부 클래스의 필드에서는 자신이랑 같이 올라와 있는 내부 클래스를<br>
> 바로 객체화 할 수 있다. 보통은 어떤 메서드의 호출 결과로 내부 객체를 <br>
> 부여받아서 사용하는 방식으로 설계된다.


외부클래스명 객체명 = new 외부클래스생성자();<br>
외부클래스명.내부클래스명 객체명 = 외부클래스객체.new 내부클래스생성자();

## 11.-1 내부 클래스를 사용하는 이유

1. 상속처럼 이용 <br>
	외부 클래스의 필드를 마치 내것처럼 접근하여 사용하기 위함 <br>
2. 캡슐화 <br>
	외부 클래스의 객체가 없다면 내부 클래스도 존재할 수 없기 때문에 <br>
	다른 클래스에서 접근하지 못하도록 내부 클래스를 숨기기 위함

가정
> B 클래스의 b() 메서드가 자주 쓰이고 이 작업은 A 클래스의 데이터가 필요하다.<br>
> 만약 다른 곳에서는 b() 메서드가 전혀 안쓰이거나, B 클래스를 외부에 노출시키고 싶지<br>
> 않거나, B 클래스의 객체가 있기 전에 필수적으로 A 클래스의 객체가 있어야 한다면 <br>
> 설계를 내부 클래스 형태로 만들어서 사용한다.

# 12. 익명 클래스 (anonymous inner class)
> 이름이 없는 클래스 <br>

익명 클래스는 앞에 있는 생성자의 클래스를 상속받고 있는 이름없는 자식 클래스이다.<br>
일회용 클래스이다. <br>
그 앞에있는 생성자를 통해 만드는 객체 딱 하나만을 위한 클래스이다.<br>
그 때 만들어지는 객체는 익명 클래스 안에서 구현한 메서드의 내용을 가지게 된다.<br>
이렇게 만들어지는 객체는 익명구현객체 라고 한다.<br>

새로운 메서드를 구현하게 되면 자식에서 내용을 추가하는 것이나 마찬가지이고 <br>
만들어지는 쟂체를 이 익명 클래스 타입으로 다운캐스팅을 해야만 사용 가능하다. <br>
하지만 익명클래스는 일회용으로 이름이 없기 때문에 다운캐스팅이 불가능하다. <br>
따라서 새로운 메서드는 이 영역 내부에서만 사용 가능하다.<br>

# 13. 예외 처리
- 에러 : 심각한 오류
- 예외 : 덜 심각한 오류 <br>

## 13.-1 try ~ catch ~ finally
```java
try {
	예외가 발생할 수 있는 문장
	...
}
catch(예외클래스 객체명){
	예외 발생시 실행할 문장
}
...
finally{
	예외 발생 여부에 상관없이 실행할 문장
}
```

## 13.-2 Exception 클래스
> 모든 예외들의 부모클래스

## 13.-3 throws
> 메서드 선언부 내부에서 발생하는 예외를 무시하고<br>
> 호출하는 곳으로 떠넘기는 문법<br>
> 호출하는 곳에서 예외가 발생할 수 있기 때문에 <br>
> try~catch로 잡아주어야 한다. <br>

```java
리턴타입 메서드명() throws 예외1, 예외2,...{
	예외1, 예외2, ... 무시하는 구역
}
```

# 14. API (Application Programing Interface)
> 자바 시스템을 제어하기 위해서 자바에서 제공하는 명령어들을 의미한다.<br>
> 선배 개발자들이 JAVA에서 코딩을 쉽게 할 수 있도록 미리 만들어 놓은것들 <br>
> API의 종류는 굉장히 많고 다양하기 때문에 모두 외우는 것은 절대 불가능하다.<br>
> 그렇기 때문에 처음 보는 API라도 설명과 이름, 매개변수 등을 잘 읽고 <br>
> 맞는 목적으로 잘 사용하는 방법을 알아야 한다.

# 15. Object 클래스
> 모든 클래스들의 최상위 클래스

- toString() : 객체 출력시 나올 문자열 정의(객체에 대해 설명하는 문자열) <br>

- == : 두 주소값이 같은지 확인하는 연산자
- equals() : 두 주소값이 같은지 확인하는 메서드
- hashCode() : 해쉬값(주소값 관련된 고유한 int값)을 리턴 <br>

우리가 만드는 클래스에서는 주소값이 아닌 다른 값으로 활용할 수 있도록 <br>
재정의 할 수 있는 능력이 필요하다. <br>

### Math 클래스
> 수학적인 메서드들과 계산에 필요한 상수를 가지고 있는 클래스

# 16. Wrapper 클래스
> 기본형 타입의 변수를 객체로 사용 가능하게 도와주는 클래스<br>
> 기본형 타입의 클래스 타입<br>
> 기본형 타입의 값을 마치 객체로 감싸고 있다고 보여서 Wrapper 클래스<br>

- int --> Integer
- char --> Character
- ...

```java
Wrapper클래스명 객체명 = new Wrapper생성자(값);	//박싱
Wrapper클래스명 객체명 = (Wrapper클래스명)값;	//박싱

Wrapper객체.자료형Value();			//언박싱

//jdk 1.5버전부터는 오토를 지원한다.
Wrapper클래스명 객체명 = 일반자료형값;		//오토박싱
기본자료형 변수명 = Wrapper객체;			//오토언박싱
```
## Wrapper 클래스를 사용하는 이유
- 기본형 타입을 객체로 다루어야 할 때
- 기본형 타입이 아닌 객체로 값을 저장해야 할 때
- 매개변수로 객체를 넘길 때(특히 Object 타입에)
- 객체간의 비교가 필요할 때

# 17. Generic (제네릭)
> 자료형을 선언할 때 정하지 않고 사용할 때 정해주는 기법<br>

&nbsp; <키워드> <br>
E : Element <br>
N : Number <br>
T : Type <br>
K : Key <br>
V : Value <br>

1. 제네릭 클래스 <br>
클래스 내부에서 사용될 자료형을 지정한다.
```java
class 클래스명<키워드>{
	내부에서 키워드를 타입으로 사용 가능
}
```
2. 제네릭 메서드 <br>
메서드 내주에서 사용될 자료형을 지정한다.
```java
<키워드>리턴타입 메서드명(){
	내부에서 키워드를 타입으로 사용 가능
}
```

3. 제네릭 인터페이스 <br>
인터페이스 내부에서 사용될 자료형을 지정한다.
```java
interface 인터페이스명<키워드>{
	내부에서 키워드를 타입으로 사용 가능
}
```

# 18. 컬렉션 프레임워크 (Collection Framework) <br>
많은 데이터들을 쉽고 효과적으로 관리할 수 있는 <br>
표준화된 방법을 제공하는 클래스 및 인터페이스의 집합<br>
자료구조의 일종<br>
 
 <table>
	<tr>
		<td></td>
		<td colspan="2">Collection (I)</td>
	</tr>
	<tr>
		<td></td>
		<td>List (I)</td>
		<td>Set (I)</td>
	</tr>
	<tr>
		<td rowspan="3">구현 클래스</td>
		<td>ArrayList</td>
		<td>HashSet</td>
	</tr>
	<tr>
		<td>LinkedList</td>
		<td>TreeSet</td>
	</tr>
	<tr>
		<td>Vector</td>
		<td></td>
	</tr>
</table>

## ArrayList <br>
Array는 배열 이라는 뜻이고 List는 원소들의 나열된 묶음이다. <br>
ArrayList는 배열을 이용해서 원소들을 나열해 묶는 클래스이다.<br>
컬렉션 클래스들 중 가장 많이 사용되는 클래스이다. <br><br>
인덱스를 이용해서 배열 요소에 빠르게 접근 가능하지만 <br>
크기를 늘리기 위해서(요소를 추가할 때) 새로운 배열을 생성하고<br>
기존의 값들을 옮겨야 하므로 느리다. <br><br>
배열은 처음에 몇 칸을 할당할지 고정해야 했지만,<br>
ArrayList는 값을 넣는 만큼 자동으로 늘어난다.<br><br>

## HashSet <br>
Hash는 해시값 Set은 집합이라는 뜻이다.<br>
집합은 중복되는 원소(요소, 값)를 포함할 수 없다.<br>
저장된 값들에는 인덱스가 없기 때문에 저장 순서가 고정되어 있지 않다.<br>
값의 포함 여부, 값의 유무 검사 목적이 있다.<br><br>
Set은 검색의 목적이 있기 때문에 수서 정보를 관리할 필요가 없다.<br>
따라서 데이터 크기에 상관없이 검색에 걸리는 시간이 매우 짧다.<br>
반면 ArrayList는 인덱스를 관리해야 하기 때문에 상대적으로<br>
시간이 오래 걸린다. 기능적으로 HashSet과 ArrayList로 <br>
구현할 것이 차이가 없다면 HashSet을 이용한다.<br><br>

- iterator() <br>
순서가 없는 Set 타입의 요소에 숭서를 부여해서 Iterator로 <br>만든 후 리턴해주는 메서드이다. <br>리턴된 Iterator 객체는 순서가 부여되어 있기 때문에 <br>안에 있는 요소들을 .next()라는 메서드를 통해서 하나씩 가져올 수 있게된다.<br>

## HashMap <br>
Map 구조는 Key(키)와 Value(값)가 쌍으로 저장되는 형태이다.<br>
그러므로 검색에 용이하다.<br>
KEY는 중복이 불가능하며, VALUE는 가능하다.<br>
KEY는 Set타입이고, VALUE는 Collection 타입이다.<br>

<table>
	<tr>
		<td></td>
		<td>KEY</td>
		<td>VALUE</td>
	</tr>
	<tr>
		<td>ENTRY</td>
		<td>fly</td>
		<td>날다</td>
	</tr>
	<tr>
		<td>ENTRY</td>
		<td>walk</td>
		<td>걷다</td>
	</tr>
	<tr>
		<td>ENTRY</td>
		<td>run</td>
		<td>뛰다</td>
	</tr>
</table>

- .keySet()<br>
Key들만 모여있는 Set
- .values()<br>
Value들만 모여있는 Collection
- .entrySet()<br>
키, 값이 하나의 Entry로 모여있는 Set

## 컬렉션 사용시 주의할 점 <br>
컬렉션에서는 값들을 비교할 때 요소 타입의 equals() 혹은 <br>
hashCode()로 비교하기 때문에 우리가 만든 클래스에 그것들을 <br>
재정의하지 않는다면 주소값 비교로 같은 값을 찾아올 수 가 없게 된다.<br>
따라서 비교하고자 하는 값을 올바르게 비교하도록 equals()를 재정의해서 사용해야 한다.

# 19. 빠른 for문(향상된 for문, forEach문) <br>
> 단순하게 모든 값들을 순회할 때 사용하는 것이 좋다. <br>
> 순서가 중요한 경우에는(몇번째에 어떤 값이 있는지 알 필요가 있는 경우)<br>
> 기존의 for문을 이용하는것이 좋다. <br>

```java
for(자료형 변수명 : 반복자) {
	변수가 안에 있는 요소들을 하나씩 꺼내오며 반복
}
```

# 20. Thread (쓰레드)

## 프로세스
> 실행된 프로그램<br>
> 운영체제로부터 시스템 자원을 할당받는 작업의 단위 <br>
> 자바 프로그램은 운영체제 대신 JVM에 의해 자원을 할당받는다.<br>

## 쓰레드
> 프로세스의 특정한 수행 경로<br>
> 프로그램의 처리 경로<br>
> 프로그램의 흐름<br>

## 멀티 쓰레드
> 하나의 프로세스를 동시에 처리하는 것처럼 보이지만<br>
> 사실은 매우 짧은 단위로 분할해서 차례대로 처리한다.<br>
> 여러개의 경로를 가질 수 있게 한다.<br>
> 한개의 처리 경로를 여러개로 나누어 동시 작업이 가능해진다.<br>
> 웹 페이지(JSP)가 대표적인 멀티 쓰레드 응용 프로그램이다.<br>

#### 장점
- 효율성 증가
- 처리량 증가
- 처리비용 감소

#### 단점
- 복잡하고 설계가 어려움
- 자원의 공유문제
- 교착상태(Deadlock)

#### 교착상태<br>
멀티 쓰레드 중 쓰레드 간의 대기 상태가 종료되지 않아서 <br>
무한정 대기만 하는 비정상적인 상태<br><br>
해결방법 : 제어문을 통해 교착상태를 판단하고 다시 깨워준다.<br>

#### 쓰레드 생성
1. Thread 클래스 상속
2. Runnable 인터페이스 지정 후 Thread 객체에 넘겨주기

## 동기화(synchronized)
> 하나의 쓰레드가 실행 중일 때 다른 쓰레드가 동시에<br>
> 같은 필드를 사용하지 못하도록 막는 것

```java
synchronized(this){
	//다른 쓰레드가 동시에 접근 불가
}
```

# 21. 파일 입출력
## Writer(입력) <br>
FileWriter > BufferWriter > 파일에 입력

- FileWriter : 경로에 있는 파일을 가져오기(쓰기위해) <br> *파일이 없는 경우에는 그 이름대로 파일을 생성해준다. <br> *하지만 경로가 이상한 경우에는(폴더가 잘못된 폴더인 경우)<br>폴더를 생성해 주지는 않고, 예외가 발생한다.
- new FileWriter("파일경로") : 덮어쓰기 모드
- new FileWriter("파일경로", true) : 추가모드

- BufferedWriter : 버퍼를 이용해서 파일 작성
- bw.write("문자열") : 버퍼에 문자열 쓰기
- bw.close() : 실제 파일에 적용 <br> 버퍼에 있는 데이터들을 파일에 써주면서 버퍼 닫기.

## Reader(출력) <br>
FileReader > BufferedReader > 파일에서 출력

- FileReader : 경로에 있는 파일 가져오기(읽기 위해)<br>*파일이 없으면 예외 발생(FNFE)
- BufferedReader : 버퍼를 이용해서 파일 읽기

# 22. MVC 모델 <br>
소프트웨어 설계시 사용되는 디자인 패턴<br>
만드는 방법이 아닌 "잘" 만들기<br>
- M : Model 데이터와 대응
- V : View 보여지는 화면
- C : Controller 흐름, 처리 담당

## MVC 1 <br>
View, Controller 가 함께 공존하는 형태

## MVC 2 <br>
View Controller 가 분리된 형태

## DTO (Data Transfer Object) / VO (Value Object)<br>
데이터 전송 객체 <br>
양쪽으로 전송되어 오고가는 데이터들을 담은 객체<br>
여러 데이터들을 포장해서 만든 데이터 포장 객체<br>

## DAO (Data Access Object)<br>
데이터 접근 객체 <br>
데이터들을 관리하는(추가, 수정, 삭제, 조회 CRUD)<br>
여러 메서드들이 정의되어 있다.<br>
Create, Read, Update, Delete<br>
















